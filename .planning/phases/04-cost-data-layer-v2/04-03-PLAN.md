---
phase: 04-cost-data-layer-v2
plan: 03
type: execute
wave: 3
depends_on:
  - 04-02
files_modified:
  - src/lib/engine/packagingEngine.ts
  - src/lib/engine/costProvider.ts
autonomous: true
requirements:
  - WEIGHT-01
  - WEIGHT-02
  - WEIGHT-03

must_haves:
  truths:
    - "The engine calculates total weight per box from product_attributes.weight"
    - "For PostNL carriers (weight_bracket is NOT NULL), the correct bracket is selected based on total weight"
    - "For DPD/pallet carriers (weight_bracket IS NULL), weight is ignored for cost selection"
    - "In multi-box scenarios, each box has its own weight and bracket calculated independently"
  artifacts:
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "Weight-aware cost enrichment in enrichWithCosts and solveMultiBox"
      contains: "selectCostForWeight"
    - path: "src/lib/engine/costProvider.ts"
      provides: "selectCostForWeight function for bracket selection"
      contains: "selectCostForWeight"
  key_links:
    - from: "src/lib/engine/packagingEngine.ts"
      to: "src/lib/engine/costProvider.ts"
      via: "selectCostForWeight called with box weight"
      pattern: "selectCostForWeight"
    - from: "src/lib/engine/packagingEngine.ts"
      to: "batchmaker.product_attributes"
      via: "weight field from product_attributes for total box weight calc"
      pattern: "weight"
---

<objective>
Integrate weight bracket calculation into the engine's cost enrichment pipeline. The engine calculates total weight per box from product weights and selects the correct cost entry based on weight bracket.

Purpose: PostNL transport costs depend on weight brackets (0-5kg, 5-10kg, 10-20kg, 20-30kg). Without weight-aware cost selection, the engine would use incorrect transport costs for PostNL shipments. DPD/pallet have a single cost regardless of weight.

Output: Weight-aware enrichWithCosts that selects the correct bracket per box.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cost-data-layer-v2/04-01-SUMMARY.md
@.planning/phases/04-cost-data-layer-v2/04-02-SUMMARY.md
@src/lib/engine/packagingEngine.ts
@src/lib/engine/costProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement weight-aware cost enrichment in the engine</name>
  <files>src/lib/engine/packagingEngine.ts, src/lib/engine/costProvider.ts</files>
  <action>
1. **Ensure selectCostForWeight is exported** from costProvider.ts (it should be from Plan 02, verify it's exported and the bracket parsing is correct):
   - '0-5kg' -> max 5000g
   - '5-10kg' -> max 10000g
   - '10-20kg' -> max 20000g
   - '20-30kg' -> max 30000g
   - NULL -> matches any weight (DPD/pallet)
   - Selection logic: find the smallest bracket that fits. If weight exceeds all brackets, return null.
   - If entries include NULL bracket entries, prefer the bracketed match; fall back to NULL entry only if no bracket matches.

2. **Add weight calculation helper** to packagingEngine.ts:
   ```typescript
   /**
    * Calculate total weight of products assigned to a box (in grams).
    * Uses product_attributes.weight data already available in mixableMap/weightMap.
    */
   function calculateBoxWeight(
     boxProducts: { productcode: string; quantity: number }[],
     weightMap: Map<string, number>  // productcode -> weight in grams
   ): number {
     let total = 0
     for (const bp of boxProducts) {
       total += (weightMap.get(bp.productcode) ?? 0) * bp.quantity
     }
     return total
   }
   ```

3. **Refactor enrichWithCosts to be weight-aware**:

   The challenge is that enrichWithCosts currently runs BEFORE products are assigned to boxes (it enriches PackagingMatch candidates). Weight is only known AFTER products are assigned. So we need a two-pass approach:

   **Pass 1 (existing enrichWithCosts)**: Keep current behavior but use the NULL-bracket or lightest-bracket entry as initial cost estimate for ranking. This is used during matchCompartments -> enrichWithCosts -> rankPackagings.

   **Pass 2 (new function `refineBoxCostWithWeight`)**: After products are assigned to a box (in solveMultiBox and the single-box path), recalculate the cost using the actual weight:
   ```typescript
   function refineBoxCostWithWeight(
     box: AdviceBox,
     costEntries: CostEntry[] | undefined,
     weightMap: Map<string, number>
   ): AdviceBox {
     if (!costEntries || costEntries.length === 0) return box

     const weight = calculateBoxWeight(box.products, weightMap)
     const entry = selectCostForWeight(costEntries, weight)
     if (!entry) return box  // No bracket for this weight

     return {
       ...box,
       box_cost: entry.boxCost,
       transport_cost: entry.transportCost,
       total_cost: entry.totalCost,
       weight_grams: weight,           // NEW: track weight on AdviceBox
       weight_bracket: entry.weightBracket,  // NEW: track selected bracket
     }
   }
   ```

4. **Update AdviceBox type** to include optional weight fields:
   ```typescript
   export interface AdviceBox {
     // ... existing fields ...
     weight_grams?: number        // Total weight of products in this box (grams)
     weight_bracket?: string | null  // Selected weight bracket (e.g., '0-5kg')
   }
   ```

5. **Thread weight refinement through solveMultiBox**:

   The `mixableMap` already has `weight` per product (fetched from product_attributes). Build a `weightMap: Map<string, number>` (productcode -> weight) from mixableMap at the start of solveMultiBox.

   After each AdviceBox is created (both for non-mixable single boxes and mixable boxes), call `refineBoxCostWithWeight` to replace the initial cost estimate with the weight-aware cost.

   For non-mixable products: the box has 1 product with qty 1, so weight is straightforward.

   For mixable multi-box: each box has its own product list, calculate weight per box.

6. **Thread weight refinement through calculateAdvice single-box path**:

   In calculateAdvice, after `solveMultiBox` returns boxes, the costs are already refined inside solveMultiBox. No additional changes needed in calculateAdvice itself.

7. **Handle WEIGHT-03 (multi-box per-box weight)**: Already handled by step 5 — each box gets its own `refineBoxCostWithWeight` call with its own product list.

8. **Edge cases**:
   - Product with no weight in product_attributes (weight=0 or null): treat as 0g, log a warning
   - Box weight exceeds 30kg: no PostNL bracket available. If only PostNL entries exist for this SKU/country, the box gets no cost (or falls back to non-bracketed entry if one exists)
   - Box with only composition parts `(composition parts)` productcode: weight won't be in weightMap; treat as 0g with a warning. This is acceptable — compositions are already partially classified.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify the engine compiles and the weight logic is structurally correct. Full integration test requires published_box_costs data with weight brackets.</manual>
  </verify>
  <done>The engine calculates per-box weight from product_attributes.weight. For PostNL boxes, the correct weight bracket is selected based on total weight (0-5kg, 5-10kg, 10-20kg, 20-30kg). For DPD/pallet (NULL bracket), weight is ignored. Multi-box orders get per-box weight calculation. AdviceBox carries weight_grams and weight_bracket fields.</done>
</task>

<task type="auto">
  <name>Task 2: Verify full compilation and update PackagingAdviceResult</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
1. Ensure `PackagingAdviceResult` type is updated if needed. The advice_boxes array already contains AdviceBox objects, and the new weight_grams/weight_bracket fields are optional, so the existing DB column (`advice_boxes JSONB`) will simply include the extra fields. No DB migration needed.

2. Run `npm run build` to verify the full production build compiles (not just tsc --noEmit). This catches any runtime import issues.

3. Verify the full import chain is intact:
   - costProvider.ts exports: getAllCostsForCountry (returns Map<string, CostEntry[]>), selectCostForWeight, invalidateCostCache, CostEntry type
   - packagingEngine.ts imports: getAllCostsForCountry, selectCostForWeight, CostEntry from costProvider
   - The webhook route imports invalidateCostCache from costProvider

4. Check that all usages of `CostEntry` in the codebase (grep for it) use the new type correctly. The UI components in Phase 3 read `box_cost`, `transport_cost`, `total_cost` from AdviceBox — these still work because the fields are preserved.

5. If build fails, fix the issues. Common causes:
   - Type mismatch where `CostEntry` was used as a single object but is now in an array
   - Missing imports for `selectCostForWeight`
   - Optional chaining needed for `weight_bracket` on AdviceBox
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npm run build 2>&1 | tail -20</automated>
    <manual>Verify the build succeeds with exit code 0 and no type errors.</manual>
  </verify>
  <done>Full production build passes. All import chains are intact. CostEntry type is used consistently. AdviceBox with weight fields is backward compatible with existing UI. The weight bracket pipeline is complete from product_attributes.weight through to AdviceBox.weight_bracket.</done>
</task>

</tasks>

<verification>
1. Full build succeeds: `npm run build`
2. TypeScript compiles: `npx tsc --noEmit`
3. AdviceBox type includes weight_grams and weight_bracket
4. enrichWithCosts uses initial bracket estimate, refineBoxCostWithWeight uses actual weight
5. Multi-box: each box has independent weight calculation
</verification>

<success_criteria>
- Engine calculates total weight per box from product weights
- PostNL boxes get the correct weight bracket based on actual product weight
- DPD/pallet boxes ignore weight brackets (use NULL-bracket entry)
- Multi-box orders have per-box weight and bracket
- Full production build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-cost-data-layer-v2/04-03-SUMMARY.md`
</output>
