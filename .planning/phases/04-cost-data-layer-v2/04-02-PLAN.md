---
phase: 04-cost-data-layer-v2
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/types/verpakking.ts
  - src/lib/engine/costProvider.ts
  - src/lib/engine/packagingEngine.ts
  - src/app/api/verpakking/engine/cache-invalidate/route.ts
autonomous: true
requirements:
  - COST-01
  - COST-02
  - COST-03
  - COST-04
  - SKU-03
  - DEGRAD-01
  - DEGRAD-03

must_haves:
  truths:
    - "costProvider reads from published_box_costs via facturatie_box_sku join key"
    - "CostEntry includes weight_bracket, box_pick_cost, box_pack_cost fields"
    - "Cost data is cached in-memory with 15-min TTL"
    - "A webhook POST to /api/verpakking/engine/cache-invalidate clears the cost cache"
    - "Missing facturatie_box_sku mappings are logged as warnings at fetch time"
    - "When facturatie DB is unreachable, engine falls back to specificity ranking without crash"
    - "After cache TTL expires, system automatically fetches fresh data (auto-recovery)"
  artifacts:
    - path: "src/lib/engine/costProvider.ts"
      provides: "Rewritten cost provider reading from published_box_costs"
      contains: "published_box_costs"
    - path: "src/types/verpakking.ts"
      provides: "Extended CostEntry with weight_bracket, box_pick_cost, box_pack_cost"
      contains: "weightBracket"
    - path: "src/app/api/verpakking/engine/cache-invalidate/route.ts"
      provides: "Webhook endpoint for cache invalidation"
      exports: ["POST"]
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "Engine using facturatie_box_sku for cost lookup instead of barcode"
      contains: "facturatie_box_sku"
  key_links:
    - from: "src/lib/engine/costProvider.ts"
      to: "facturatie published_box_costs"
      via: "getFacturatieSupabase().from('published_box_costs')"
      pattern: "published_box_costs"
    - from: "src/lib/engine/packagingEngine.ts"
      to: "src/lib/engine/costProvider.ts"
      via: "getAllCostsForCountry with facturatie_box_sku lookup"
      pattern: "facturatie_box_sku"
    - from: "src/app/api/verpakking/engine/cache-invalidate/route.ts"
      to: "src/lib/engine/costProvider.ts"
      via: "invalidateCostCache()"
      pattern: "invalidateCostCache"
---

<objective>
Rewrite costProvider.ts to read from `published_box_costs` table with `facturatie_box_sku` as join key, extend CostEntry type with weight brackets and pick/pack costs, add webhook endpoint for cache invalidation, and validate SKU mappings at fetch time.

Purpose: The v1 costProvider reads from incorrect tables (packaging_costs + shipping_rates) that don't match the real facturatie schema. This rewrite connects to the correct `published_box_costs` contract table with proper SKU mapping, weight bracket support, and pick/pack cost fields.

Output: Working cost data pipeline that reads from the correct source, with cache invalidation and degradation support.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cost-data-layer-v2/04-01-SUMMARY.md
@src/lib/engine/costProvider.ts
@src/lib/engine/packagingEngine.ts
@src/types/verpakking.ts
@src/lib/supabase/facturatieClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite CostEntry type and costProvider to read from published_box_costs</name>
  <files>src/types/verpakking.ts, src/lib/engine/costProvider.ts</files>
  <action>
1. Update `CostEntry` in `src/types/verpakking.ts`. Replace the existing interface with:
   ```
   export interface CostEntry {
     boxSku: string              // published_box_costs.box_sku (join key)
     boxName: string             // published_box_costs.box_name
     countryCode: string         // published_box_costs.country_code
     carrier: string             // published_box_costs.carrier_code
     tariffClass: string         // published_box_costs.tariff_class ('laag' or 'hoog')
     weightBracket: string | null // published_box_costs.weight_bracket ('0-5kg', '5-10kg', etc. or NULL)
     isPallet: boolean           // published_box_costs.is_pallet
     vehicleType: string | null  // published_box_costs.vehicle_type (COL, HEU, EWP, BLOK or null)
     boxMaterialCost: number     // published_box_costs.box_material_cost
     boxPickCost: number         // published_box_costs.box_pick_cost
     boxPackCost: number         // published_box_costs.box_pack_cost
     transportCost: number       // published_box_costs.transport_purchase_cost
     totalCost: number           // published_box_costs.total_cost
     calculatedAt: string        // published_box_costs.calculated_at (ISO timestamp)
     // v1 compatibility aliases (computed)
     boxCost: number             // = boxMaterialCost (backward compatible with enrichWithCosts)
   }
   ```
   Keep the old fields `boxCost` and `transportCost` as they are used in enrichWithCosts and the UI.

2. Rewrite `src/lib/engine/costProvider.ts`:

   **Cache structure change**: The cache key changes from `country -> sku -> CostEntry` to `country -> sku -> CostEntry[]` (array, because PostNL boxes have multiple weight brackets per SKU/country combo). Add a helper `getCostForWeight(entries: CostEntry[], weightGrams: number): CostEntry | null` that selects the correct bracket.

   Actually, keep it simpler for now. The cache structure should be:
   - `Map<string, Map<string, CostEntry[]>>` — country_code -> box_sku -> CostEntry[] (one per weight_bracket)

   **New public API**:
   ```typescript
   // Get all cost entries for a country. Returns Map<box_sku, CostEntry[]> or null if unreachable.
   export async function getAllCostsForCountry(countryCode: string): Promise<Map<string, CostEntry[]> | null>

   // Select the correct cost entry for a given weight in grams. Returns the matching bracket or heaviest bracket as fallback.
   export function selectCostForWeight(entries: CostEntry[], weightGrams: number): CostEntry | null

   // Clear cache (existing, keep same signature)
   export function invalidateCostCache(): void
   ```

   **fetchAllCosts rewrite**: Query `published_box_costs` from facturatie DB:
   ```typescript
   const { data, error } = await facturatieSupabase
     .from('published_box_costs')
     .select('box_sku, box_name, country_code, carrier_code, tariff_class, weight_bracket, is_pallet, vehicle_type, box_material_cost, box_pick_cost, box_pack_cost, transport_purchase_cost, total_cost, calculated_at')
   ```
   No filters needed (we want all rows, ~350-400). Build nested Map: country_code (uppercase) -> box_sku -> CostEntry[].

   **selectCostForWeight implementation**:
   - Parse weight brackets: '0-5kg' -> max 5000g, '5-10kg' -> max 10000g, '10-20kg' -> max 20000g, '20-30kg' -> max 30000g
   - NULL weight_bracket entries (DPD/pallet) always match any weight
   - For PostNL (has brackets): select the bracket where weightGrams <= bracket max
   - If weight exceeds all brackets (>30kg), return null (no PostNL option available)
   - If no bracket match but NULL entries exist, return the NULL entry

   **SKU mapping validation** (SKU-03): After fetching cost data successfully, fetch all active packagings from batchmaker that have `use_in_auto_advice = true`, check which ones have `facturatie_box_sku IS NOT NULL` but their SKU doesn't appear in the fetched cost data. Log these as warnings:
   `[costProvider] WARNING: packaging "{name}" (facturatie_box_sku={sku}) has no cost data in published_box_costs`
   Also log packagings that have `facturatie_box_sku IS NULL`:
   `[costProvider] INFO: packaging "{name}" has no facturatie_box_sku mapping - will use specificity ranking`
   Do this check only once per cache refresh (not every call). Use a separate boolean flag `validationDone`.

   **Graceful degradation** (DEGRAD-01, DEGRAD-03): Keep the same pattern as v1 — return null from getAllCostsForCountry on any error. Cache TTL expiry (DEGRAD-03) automatically re-fetches, so after facturatie DB recovers the system auto-heals.

   **Numeric parsing**: Use `parseFloat(String(...))` for all numeric fields from Supabase (same pattern as v1, documented in STATE.md).
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>The costProvider compiles and the types are consistent. Full integration test requires published_box_costs to be populated in facturatie DB.</manual>
  </verify>
  <done>costProvider reads from published_box_costs. CostEntry has weight_bracket, boxPickCost, boxPackCost. selectCostForWeight correctly selects bracket based on weight. SKU mappings are validated with warnings at cache refresh. Graceful degradation returns null on failure.</done>
</task>

<task type="auto">
  <name>Task 2: Update engine to use facturatie_box_sku lookup + add webhook endpoint</name>
  <files>src/lib/engine/packagingEngine.ts, src/app/api/verpakking/engine/cache-invalidate/route.ts</files>
  <action>
1. Update `packagingEngine.ts` to use `facturatie_box_sku` for cost lookup:

   **PackagingRow type**: Add `facturatie_box_sku: string | null` field.

   **matchCompartments query**: Add `facturatie_box_sku` to the SELECT: `.select('id, idpackaging, name, barcode, facturatie_box_sku, picqer_tag_name, specificity_score, volume, handling_cost, material_cost, max_weight')`

   **PackagingMatch type**: Add `facturatie_box_sku: string | null` field.

   **In the matchCompartments match builder**: Pass `facturatie_box_sku: pkg.facturatie_box_sku ?? null` to each PackagingMatch.

   **enrichWithCosts function**: Change the lookup key from `match.barcode` to `match.facturatie_box_sku`:
   ```typescript
   function enrichWithCosts(
     matches: PackagingMatch[],
     costMap: Map<string, CostEntry[]> | null  // NOW CostEntry[] per SKU
   ): PackagingMatch[] {
     if (!costMap) return matches
     return matches
       .map(match => {
         if (!match.facturatie_box_sku) return match  // No SKU mapping → keep as-is
         const entries = costMap.get(match.facturatie_box_sku)
         if (!entries || entries.length === 0) return null  // No cost data → EXCLUDE
         // For now, use the first entry (weight bracket selection happens later in Phase 4 plan 03)
         // Use the entry with NULL weight_bracket if available, otherwise first
         const entry = entries.find(e => e.weightBracket === null) ?? entries[0]
         return {
           ...match,
           box_cost: entry.boxCost,
           transport_cost: entry.transportCost,
           total_cost: entry.totalCost,
         }
       })
       .filter((m): m is PackagingMatch => m !== null)
   }
   ```

   **getAllCostsForCountry return type**: Update all call sites to handle the new `Map<string, CostEntry[]>` return type. The function is called in calculateAdvice and solveMultiBox. Update the `costMap` parameter type throughout:
   - `calculateAdvice`: `costMap` becomes `Map<string, CostEntry[]> | null`
   - `solveMultiBox`: same type change

   **Important**: Keep `boxCost` as the backward-compatible alias (= boxMaterialCost). The enrichWithCosts function sets `box_cost` from `entry.boxCost` which is the alias for `boxMaterialCost`. The total_cost from published_box_costs already includes pick+pack, so the AdviceBox.total_cost will now reflect the full cost.

2. Create `src/app/api/verpakking/engine/cache-invalidate/route.ts`:
   ```typescript
   import { NextResponse } from 'next/server'
   import { invalidateCostCache } from '@/lib/engine/costProvider'

   export const dynamic = 'force-dynamic'

   /**
    * POST /api/verpakking/engine/cache-invalidate
    * Webhook endpoint for facturatie-app to invalidate the cost cache
    * when tariffs are recalculated.
    *
    * No auth required (internal network only, cache invalidation is safe).
    * The facturatie-app POSTs here after updating published_box_costs.
    */
   export async function POST() {
     try {
       invalidateCostCache()
       console.log('[cache-invalidate] Cost cache invalidated via webhook')
       return NextResponse.json({ success: true, message: 'Cost cache invalidated' })
     } catch (error) {
       console.error('[cache-invalidate] Error:', error)
       return NextResponse.json(
         { error: 'Failed to invalidate cache', details: error instanceof Error ? error.message : 'Unknown error' },
         { status: 500 }
       )
     }
   }
   ```
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify that the engine compiles and the new webhook route exists. Full integration test requires the facturatie DB to have published_box_costs data.</manual>
  </verify>
  <done>Engine uses facturatie_box_sku instead of barcode for cost lookup. costMap type is CostEntry[] throughout. Webhook endpoint at /api/verpakking/engine/cache-invalidate clears cache on POST. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. costProvider.ts reads from `published_box_costs` (not shipping_rates/packaging_costs)
3. CostEntry type includes weightBracket, boxPickCost, boxPackCost
4. Engine uses facturatie_box_sku for cost lookup (not barcode)
5. Webhook endpoint exists at /api/verpakking/engine/cache-invalidate
6. Graceful degradation: getAllCostsForCountry returns null on error (never throws)
</verification>

<success_criteria>
- costProvider fetches from published_box_costs with all new fields
- selectCostForWeight correctly parses weight brackets and selects appropriate entry
- Engine cost lookup uses facturatie_box_sku from packagings table
- Cache invalidation webhook responds 200 on POST
- TypeScript compiles without errors across the full codebase
</success_criteria>

<output>
After completion, create `.planning/phases/04-cost-data-layer-v2/04-02-SUMMARY.md`
</output>
