---
phase: 01-cost-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/costProvider.ts
  - src/types/verpakking.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03

must_haves:
  truths:
    - "costProvider.getAllCostsForCountry('NL') returns a Map of CostEntry objects keyed by packaging SKU, fetched from facturatie Supabase"
    - "Cost data is cached in-memory with 15-minute TTL -- a second call within TTL does not query facturatie database"
    - "For each box/country, only the preferred carrier (is_preferred=true, is_available=true) is returned"
    - "When facturatie database is unreachable or env vars missing, getAllCostsForCountry returns null instead of throwing"
    - "invalidateCostCache() clears the cache so the next call fetches fresh data"
  artifacts:
    - path: "src/lib/engine/costProvider.ts"
      provides: "Cross-database cost lookup with in-memory cache"
      min_lines: 80
      exports: ["getAllCostsForCountry", "invalidateCostCache", "CostEntry"]
    - path: "src/types/verpakking.ts"
      provides: "CostEntry type definition"
      contains: "CostEntry"
  key_links:
    - from: "src/lib/engine/costProvider.ts"
      to: "src/lib/supabase/facturatieClient.ts"
      via: "getFacturatieSupabase() import"
      pattern: "getFacturatieSupabase"
    - from: "src/lib/engine/costProvider.ts"
      to: "facturatie.shipping_rates JOIN packaging_costs"
      via: "Supabase query with is_preferred and is_available filters"
      pattern: "is_preferred.*true"
---

<objective>
Build the cost data provider module that fetches and caches packaging + transport cost data from the facturatie Supabase database.

Purpose: This is the foundation for cost-optimized packaging advice. Without cost data, the engine cannot rank boxes by total cost per destination country. This plan creates the data access layer that Phase 2 will use for ranking.

Output: A `costProvider.ts` module with `getAllCostsForCountry()` and `invalidateCostCache()` functions, plus `CostEntry` type.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/FACTURATIE_SPEC.md
@.planning/phases/01-cost-data-layer/01-RESEARCH.md

@src/lib/supabase/facturatieClient.ts
@src/lib/supabase/syncPackagingCosts.ts
@src/types/verpakking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CostEntry type to verpakking types</name>
  <files>src/types/verpakking.ts</files>
  <action>
Add the `CostEntry` interface to `src/types/verpakking.ts`. This type represents the cost breakdown for a single box in a specific country:

```typescript
export interface CostEntry {
  boxSku: string           // packaging_costs.sku (e.g., '55_949')
  boxName: string          // packaging_costs.name (e.g., 'Surprise box')
  boxCost: number          // packaging_costs.total_purchase_price
  transportCost: number    // shipping_rates.shipping_cost
  carrier: string          // shipping_rates.carrier (e.g., 'PostNL', 'DPD')
  totalCost: number        // boxCost + transportCost
}
```

Add it near the other engine-related types. Do NOT modify any existing types.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>CostEntry interface is exported from src/types/verpakking.ts and compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Create costProvider.ts with cached facturatie data access</name>
  <files>src/lib/engine/costProvider.ts</files>
  <action>
Create `src/lib/engine/costProvider.ts` implementing the cost data access layer. This module owns ALL facturatie cost queries.

**Architecture:**
- Module-level singleton cache (Map of Maps): `country -> sku -> CostEntry`
- 15-minute TTL using a timestamp check
- Single query fetches ALL cost data (all countries, all boxes) on first call
- Subsequent calls within TTL return cached data without database access

**Core function `getAllCostsForCountry(countryCode: string): Promise<Map<string, CostEntry> | null>`:**
1. Call `ensureCache()` to load/refresh data if needed
2. Return `cache.get(countryCode)` or empty `Map()` if country has no routes
3. Return `null` (not throw) if facturatie is unreachable

**Cache function `ensureCache()`:**
1. If cache exists and `Date.now() - cacheTimestamp < CACHE_TTL_MS` → return cached data
2. Otherwise call `fetchAllCosts()` to refresh

**Fetch function `fetchAllCosts()`:**
1. Get facturatie client via `getFacturatieSupabase()` from `@/lib/supabase/facturatieClient`
2. Query `shipping_rates` with nested select on `packaging_costs` (FK join using `!inner`):
   ```
   .from('shipping_rates')
   .select('box_sku, country_code, carrier, shipping_cost, packaging_costs!inner(sku, name, total_purchase_price)')
   .eq('is_preferred', true)
   .eq('is_available', true)
   ```
3. Build nested Map: iterate rows, create `CostEntry` per row, organize by `country_code` → `sku`

**CRITICAL: The facturatie tables are in the `public` schema** (not `shipping`). The facturatie client from `facturatieClient.ts` uses `public` schema by default, so NO `.schema()` call is needed. This is different from batchmaker which requires `.schema('batchmaker')`.

**Graceful degradation (DATA-03):**
- Wrap the ENTIRE `ensureCache()` body in try/catch
- On ANY error (env vars missing from `getFacturatieSupabase()`, network error, query error): log error with `console.error('[costProvider]', ...)`, return `null`
- `null` return signals "facturatie unavailable" to callers
- An empty `Map()` return means "country exists but has no routes" (different semantic)

**Cache invalidation:**
```typescript
export function invalidateCostCache(): void {
  costCache = null
  cacheTimestamp = 0
}
```

**Anti-patterns to AVOID:**
- Do NOT default to any country if country is missing — callers provide the country
- Do NOT use `.schema('shipping')` or `.schema('public')` — facturatie uses default public schema
- Do NOT fetch per-box or per-country in a loop — one query gets everything
- Do NOT treat missing shipping_rates row as zero cost — missing = route unavailable = that sku not in the Map for that country
- Do NOT catch errors selectively — catch everything in `ensureCache`, the cost provider must never crash the engine
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
costProvider.ts exists with:
- getAllCostsForCountry(countryCode) exported and returns Map or null
- invalidateCostCache() exported
- In-memory cache with 15-minute TTL constant
- Single Supabase query with is_preferred=true AND is_available=true filters
- Full try/catch around facturatie access returning null on any error
- CostEntry re-exported from verpakking types
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `src/lib/engine/costProvider.ts` exists with exports: getAllCostsForCountry, invalidateCostCache
- [ ] `CostEntry` type exists in `src/types/verpakking.ts`
- [ ] costProvider imports from `@/lib/supabase/facturatieClient` (not creating its own client)
- [ ] Query filters include `is_preferred = true` AND `is_available = true`
- [ ] Cache TTL constant is 15 minutes (15 * 60 * 1000)
- [ ] Return type is `Map<string, CostEntry> | null` (null = unavailable, Map = data)
- [ ] No `.schema()` calls on facturatie client
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- costProvider.ts compiles and follows established patterns from facturatieClient.ts and syncPackagingCosts.ts
- No changes to any existing file except adding CostEntry to verpakking.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-cost-data-layer/01-01-SUMMARY.md`
</output>
