---
phase: 01-cost-data-layer
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/engine/packagingEngine.ts
  - src/app/api/verpakking/engine/calculate/route.ts
  - src/components/verpakking/VerpakkingsClient.tsx
autonomous: true
requirements:
  - ENG-02
  - DATA-03

must_haves:
  truths:
    - "calculateAdvice() accepts a countryCode parameter and passes it through the full call chain"
    - "The API route POST /api/verpakking/engine/calculate accepts countryCode in the request body"
    - "VerpakkingsClient waits for order data (with deliverycountry) before calling the engine"
    - "VerpakkingsClient passes order.deliverycountry as countryCode to the engine API"
    - "buildFingerprint includes countryCode so orders for different countries get separate cached advice"
    - "The packaging_advice row includes country_code and cost_data_available fields"
    - "When facturatie is unreachable, the engine returns cost_data_available=false and uses existing specificity ranking without crashing"
    - "The PackagingAdviceResult type includes cost_data_available boolean field"
  artifacts:
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "Engine with country threading, fingerprint update, cost_data_available flag"
      contains: "countryCode"
    - path: "src/app/api/verpakking/engine/calculate/route.ts"
      provides: "API route accepting countryCode parameter"
      contains: "countryCode"
    - path: "src/components/verpakking/VerpakkingsClient.tsx"
      provides: "Client passing country from order to engine API"
      contains: "deliverycountry"
  key_links:
    - from: "src/components/verpakking/VerpakkingsClient.tsx"
      to: "/api/verpakking/engine/calculate"
      via: "fetch POST with countryCode in body"
      pattern: "countryCode.*deliverycountry"
    - from: "src/app/api/verpakking/engine/calculate/route.ts"
      to: "src/lib/engine/packagingEngine.ts"
      via: "calculateAdvice() call with countryCode parameter"
      pattern: "calculateAdvice.*countryCode"
    - from: "src/lib/engine/packagingEngine.ts"
      to: "src/lib/engine/costProvider.ts"
      via: "getAllCostsForCountry() call for graceful degradation"
      pattern: "getAllCostsForCountry"
---

<objective>
Thread the destination country code through the entire engine pipeline — from VerpakkingsClient through the API route to calculateAdvice — and integrate the cost provider for graceful degradation.

Purpose: Without country awareness, the engine cannot look up country-specific transport costs. This plan establishes the country parameter flow and connects it to the cost data layer from Plan 01. It also updates the fingerprint to prevent cross-country cache collisions.

Output: Modified packagingEngine.ts, calculate route, and VerpakkingsClient — all with country code support and cost_data_available flag.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cost-data-layer/01-RESEARCH.md
@.planning/phases/01-cost-data-layer/01-01-SUMMARY.md

@src/lib/engine/packagingEngine.ts
@src/lib/engine/costProvider.ts
@src/app/api/verpakking/engine/calculate/route.ts
@src/components/verpakking/VerpakkingsClient.tsx
@src/types/verpakking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add countryCode to engine, update fingerprint, integrate cost provider for degradation</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
Modify `src/lib/engine/packagingEngine.ts` to thread `countryCode` through the engine and integrate the cost provider for graceful degradation.

**1. Update PackagingAdviceResult interface** (around line 55):
Add `cost_data_available: boolean` field to the interface.

**2. Update buildFingerprint function** (around line 885):
Change signature to accept `countryCode`:
```typescript
function buildFingerprint(shippingUnits: Map<string, ShippingUnitEntry>, countryCode: string): string {
  const units = Array.from(shippingUnits.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(u => `${u.name}:${u.quantity}`)
    .join('|')
  return `${countryCode}|${units}`
}
```

**3. Update calculateAdvice signature** (around line 894):
Add `countryCode?: string` as the last parameter:
```typescript
export async function calculateAdvice(
  orderId: number,
  picklistId?: number,
  products?: OrderProduct[],
  shippingProviderProfileId?: number,
  countryCode?: string
): Promise<PackagingAdviceResult>
```
Note: `countryCode` is `string | undefined` (not required) for backward compatibility during Phase 1. The API route will validate and require it, but the engine function stays flexible. Callers without country get `cost_data_available: false`.

**4. Update fingerprint building** (around line 910):
```typescript
const effectiveCountry = countryCode ?? 'UNKNOWN'
const fingerprint = shippingUnits.size > 0 ? buildFingerprint(shippingUnits, effectiveCountry) : null
```

**5. Add cost data check after matchCompartments** (after line 957, before rankPackagings):
```typescript
import { getAllCostsForCountry } from './costProvider'

// Cost data availability check
let costDataAvailable = false
if (countryCode) {
  const costs = await getAllCostsForCountry(countryCode)
  costDataAvailable = costs !== null
  if (!costDataAvailable) {
    console.warn(`[packagingEngine] Cost data unavailable for ${countryCode}, using specificity ranking`)
  }
} else {
  console.warn(`[packagingEngine] No countryCode provided, cost data not available`)
}
```
IMPORTANT: In Phase 1, the cost data is fetched but NOT yet used for ranking. The ranking change comes in Phase 2. This step only sets the `costDataAvailable` flag.

**6. Update advice row insertion** (around line 1052):
Add `country_code` and `cost_data_available` to the adviceRow object:
```typescript
const adviceRow = {
  // ...existing fields...
  country_code: countryCode ?? null,
  cost_data_available: costDataAvailable,
}
```

**7. Update the select clause on the insert** (around line 1071):
Add `cost_data_available` to the `.select()` string.

**8. Update the return object** (around line 1081):
Add `cost_data_available` to the returned result:
```typescript
return {
  // ...existing fields...
  cost_data_available: inserted.cost_data_available ?? false,
}
```

**9. Update the deduplication return** (around line 931):
When returning existing advice from cache, also include `cost_data_available`:
```typescript
return {
  // ...existing fields...
  cost_data_available: existing.cost_data_available ?? false,
}
```
Also add `cost_data_available` to the `.select()` string in the deduplication query (around line 916).

**Anti-patterns to AVOID:**
- Do NOT make countryCode a required parameter on calculateAdvice — keep it optional for backward compat. The API route enforces requirement.
- Do NOT use cost data for ranking yet — that is Phase 2
- Do NOT default to 'NL' when countryCode is undefined — use 'UNKNOWN' for fingerprint, set costDataAvailable=false
- Do NOT add the `barcode` field to PackagingMatch yet — that is Phase 2 when enrichment happens
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
packagingEngine.ts has:
- countryCode parameter on calculateAdvice()
- buildFingerprint includes country
- getAllCostsForCountry called for cost_data_available flag
- cost_data_available on PackagingAdviceResult interface
- country_code and cost_data_available in advice row insert
- cost_data_available in deduplication return
  </done>
</task>

<task type="auto">
  <name>Task 2: Add countryCode to API route and wire VerpakkingsClient</name>
  <files>src/app/api/verpakking/engine/calculate/route.ts, src/components/verpakking/VerpakkingsClient.tsx</files>
  <action>
**Part A: Update API route** (`src/app/api/verpakking/engine/calculate/route.ts`):

1. Extract `countryCode` from request body alongside existing fields:
```typescript
const { orderId, picklistId, products, shippingProviderProfileId, countryCode } = body
```

2. Add validation AFTER the products validation block (around line 56). The countryCode is OPTIONAL in the API for backward compatibility during Phase 1, but if provided it must be valid:
```typescript
const VALID_COUNTRY_CODES = ['NL', 'BE', 'DE', 'FR', 'AT', 'LU', 'SE', 'IT', 'ES']
if (countryCode !== undefined && countryCode !== null) {
  if (typeof countryCode !== 'string' || !VALID_COUNTRY_CODES.includes(countryCode.toUpperCase())) {
    return NextResponse.json(
      { error: `countryCode must be one of: ${VALID_COUNTRY_CODES.join(', ')}` },
      { status: 400 }
    )
  }
}
```

3. Pass `countryCode` to `calculateAdvice()`:
```typescript
const advice = await calculateAdvice(
  orderId,
  picklistId,
  products,
  shippingProviderProfileId,
  countryCode?.toUpperCase()
)
```

Note: `.toUpperCase()` normalizes input — Picqer sends uppercase but be defensive.

**Part B: Update VerpakkingsClient** (`src/components/verpakking/VerpakkingsClient.tsx`):

1. Find the engine call useEffect (around line 286). Currently it fires when `picklist?.products` are available. Add a guard for `order?.deliverycountry`:

BEFORE (around line 287-289):
```typescript
if (engineCalledRef.current) return
if (!picklist?.products || picklist.products.length === 0) return
if (!picklist.idorder) return
```

AFTER:
```typescript
if (engineCalledRef.current) return
if (!picklist?.products || picklist.products.length === 0) return
if (!picklist.idorder) return
if (!order?.deliverycountry) return  // Wait for order data to load
```

This prevents the engine from being called before the order (with delivery country) is loaded. The order is fetched in a separate useEffect (around line 254). Without this guard, the engine could fire with undefined country.

2. Add `countryCode` to the fetch body (around line 303-308):
```typescript
body: JSON.stringify({
  orderId: picklist.idorder,
  picklistId: picklist.idpicklist,
  products,
  shippingProviderProfileId: picklist.idshippingprovider_profile ?? undefined,
  countryCode: order.deliverycountry,
}),
```

3. Update the useEffect dependency array (around line 327):
Change `[picklist]` to `[picklist, order]` to re-evaluate when order loads.

**CRITICAL timing issue:** The order is fetched asynchronously in a separate useEffect (line 254-276). The engine useEffect must wait for BOTH `picklist.products` AND `order.deliverycountry` to be available. The `engineCalledRef` prevents double-firing — once both are available and the engine fires once, it won't fire again even if `order` updates further.

**Anti-patterns to AVOID:**
- Do NOT make countryCode required in the API route body yet — keep optional for backward compat. The VerpakkingsClient will always send it, but other callers (tests, scripts) may not
- Do NOT create a silent 'NL' default anywhere
- Do NOT remove the existing `engineCalledRef` guard — it prevents duplicate engine calls
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>
API route:
- Extracts countryCode from body
- Validates against known country codes (if provided)
- Passes to calculateAdvice()

VerpakkingsClient:
- Engine useEffect guards on order?.deliverycountry
- countryCode: order.deliverycountry in fetch body
- Dependency array includes order
  </done>
</task>

<task type="auto">
  <name>Task 3: Add packaging_advice table columns for country_code and cost_data_available</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
The `packaging_advice` table needs two new columns: `country_code` and `cost_data_available`. Since this project uses Supabase MCP for migrations, create the migration.

Use `mcp__supabase__apply_migration` to add the columns:

```sql
-- Add country_code and cost_data_available to packaging_advice
ALTER TABLE batchmaker.packaging_advice
  ADD COLUMN IF NOT EXISTS country_code text,
  ADD COLUMN IF NOT EXISTS cost_data_available boolean DEFAULT true;

-- Comment for clarity
COMMENT ON COLUMN batchmaker.packaging_advice.country_code IS 'ISO country code used for this advice calculation (e.g., NL, DE, FR)';
COMMENT ON COLUMN batchmaker.packaging_advice.cost_data_available IS 'Whether transport cost data was available when this advice was calculated';
```

Migration name: `add_country_code_and_cost_data_to_packaging_advice`

After migration, run `mcp__supabase__get_advisors` to check for security issues.

**Note:** The `country_code` column is nullable because existing rows won't have it. The `cost_data_available` defaults to `true` for backward compatibility (existing advice was calculated with whatever ranking was available). New rows will explicitly set this flag.

**IMPORTANT:** This migration MUST succeed before the engine changes from Task 1 can write to these columns. If migration fails, the engine insert will fail on unknown column names.
  </action>
  <verify>
Query the packaging_advice table to confirm columns exist:
SELECT column_name, data_type, column_default
FROM information_schema.columns
WHERE table_schema = 'batchmaker' AND table_name = 'packaging_advice'
AND column_name IN ('country_code', 'cost_data_available')
  </verify>
  <done>
packaging_advice table has:
- country_code text column (nullable)
- cost_data_available boolean column (default true)
- Both columns visible in schema
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes (no type errors)
- [ ] `npm run build` succeeds
- [ ] packagingEngine.ts has countryCode parameter on calculateAdvice
- [ ] packagingEngine.ts imports and calls getAllCostsForCountry
- [ ] buildFingerprint includes country in its output
- [ ] PackagingAdviceResult has cost_data_available field
- [ ] API route extracts and validates countryCode
- [ ] VerpakkingsClient guards engine call on order?.deliverycountry
- [ ] VerpakkingsClient passes countryCode in fetch body
- [ ] packaging_advice table has country_code and cost_data_available columns
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Full build succeeds with no type errors
- Country code flows from VerpakkingsClient → API → engine → database
- Fingerprint includes country (prevents cross-country cache collisions)
- Cost data availability flag is set correctly (false when no country or facturatie unreachable)
- Existing engine behavior unchanged for callers that don't provide countryCode
</success_criteria>

<output>
After completion, create `.planning/phases/01-cost-data-layer/01-02-SUMMARY.md`
</output>
