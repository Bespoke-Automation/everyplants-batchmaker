---
phase: 05-engine-optimization
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/lib/engine/packagingEngine.ts
autonomous: true
requirements:
  - SINGLE-02
  - SINGLE-03

must_haves:
  truths:
    - "Orders with 1 unique SKU use the product's default_packaging_id when set"
    - "The single-SKU mapping has priority over compartment rules (engine is bypassed)"
    - "Orders with multiple unique SKUs or no default mapping proceed through normal engine flow"
    - "Single-SKU fast path still enriches the box with cost data when available"
  artifacts:
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "Single-SKU fast path in calculateAdvice before matchCompartments"
      contains: "default_packaging_id"
  key_links:
    - from: "src/lib/engine/packagingEngine.ts calculateAdvice"
      to: "batchmaker.product_attributes"
      via: "Query default_packaging_id for single-SKU check"
      pattern: "default_packaging_id"
    - from: "src/lib/engine/packagingEngine.ts calculateAdvice"
      to: "batchmaker.packagings"
      via: "Fetch packaging details for the default packaging"
      pattern: "default_packaging_id"
---

<objective>
Integrate the single-SKU fast path into calculateAdvice so that orders with only 1 unique product use the pre-configured default packaging, bypassing compartment rules entirely.

Purpose: Many orders contain just one product type (e.g., 6x potmaat 12 cactus). When a product has a default packaging assigned, the engine can skip the entire matchCompartments/rankPackagings flow and directly return the mapped packaging. This is faster, more consistent, and allows warehouse managers to override the engine for specific products.

Output: Single-SKU detection and fast path in calculateAdvice.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-engine-optimization/05-01-SUMMARY.md
@.planning/phases/05-engine-optimization/05-02-SUMMARY.md
@src/lib/engine/packagingEngine.ts
@src/lib/engine/costProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement single-SKU fast path in calculateAdvice</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
Read the current `calculateAdvice` function. Add a single-SKU fast path check AFTER classification (Step 1) but BEFORE matchCompartments (Step 2). The fast path fires when ALL of these conditions are met:

1. **Single unique product**: `products` array contains only 1 unique `picqer_product_id` (may have quantity > 1, that's fine — it's still 1 SKU)
2. **Product has default_packaging_id**: The product's `product_attributes.default_packaging_id` is NOT NULL
3. **Product is classified**: The product has a valid `shipping_unit_id` (not unclassified)

**Implementation**:

After the classification step and fingerprint building, add:

```typescript
// Step 1d: Single-SKU fast path
// Orders with 1 unique product that has a default packaging mapping bypass compartment rules
const uniqueProductIds = new Set(products.map(p => p.picqer_product_id))
if (uniqueProductIds.size === 1 && unclassified.length === 0) {
  const productId = products[0].picqer_product_id

  const { data: productAttr } = await supabase
    .schema('batchmaker')
    .from('product_attributes')
    .select('default_packaging_id, shipping_unit_id')
    .eq('picqer_product_id', productId)
    .single()

  if (productAttr?.default_packaging_id) {
    // Fetch the packaging details
    const { data: defaultPkg } = await supabase
      .schema('batchmaker')
      .from('packagings')
      .select('id, name, idpackaging, barcode, facturatie_box_sku, active')
      .eq('id', productAttr.default_packaging_id)
      .single()

    if (defaultPkg && defaultPkg.active) {
      console.log(`[packagingEngine] Single-SKU fast path: product ${products[0].productcode} → ${defaultPkg.name}`)

      // Build the product list for this box
      const unitName = shippingUnits.values().next()?.value?.name || 'Unknown'
      const totalQty = products.reduce((sum, p) => sum + p.quantity, 0)
      const boxProducts = [{
        productcode: products[0].productcode,
        shipping_unit_name: unitName,
        quantity: totalQty,
      }]

      // Enrich with cost data if available
      let boxCost: number | undefined
      let transportCost: number | undefined
      let totalCostValue: number | undefined

      if (countryCode && defaultPkg.facturatie_box_sku) {
        const costMap = await getAllCostsForCountry(countryCode)
        if (costMap) {
          const entries = costMap.get(defaultPkg.facturatie_box_sku)
          if (entries && entries.length > 0) {
            // Select appropriate cost entry (use selectCostForWeight if weight data available)
            // For single-SKU, calculate weight from product_attributes
            const { data: weightData } = await supabase
              .schema('batchmaker')
              .from('product_attributes')
              .select('weight')
              .eq('picqer_product_id', productId)
              .single()

            const productWeight = weightData?.weight ?? 0
            const totalWeight = productWeight * totalQty

            const entry = selectCostForWeight(entries, totalWeight)
            if (entry) {
              boxCost = entry.boxMaterialCost ?? entry.boxCost
              transportCost = entry.transportCost
              totalCostValue = entry.totalCost
              costDataAvailable = true
            }
          }
        }
      }

      const singleSkuBox: AdviceBox = {
        packaging_id: defaultPkg.id,
        packaging_name: defaultPkg.name,
        idpackaging: defaultPkg.idpackaging,
        products: boxProducts,
        box_cost: boxCost,
        transport_cost: transportCost,
        total_cost: totalCostValue,
      }

      // Skip to persistence (Step 4c+)
      // Validate weight
      const weightExceeded = !(await validateWeightsForBoxes([singleSkuBox], products))

      const shippingUnitsDetected = Array.from(shippingUnits.values()).map(entry => ({
        shipping_unit_id: entry.id,
        shipping_unit_name: entry.name,
        quantity: entry.quantity,
      }))

      const adviceRow = {
        order_id: orderId,
        picklist_id: picklistId ?? null,
        status: 'calculated' as const,
        confidence: 'full_match' as const,
        advice_boxes: [singleSkuBox],
        shipping_units_detected: shippingUnitsDetected,
        unclassified_products: [],
        tags_written: [],
        calculated_at: new Date().toISOString(),
        shipping_unit_fingerprint: fingerprint,
        shipping_provider_profile_id: shippingProviderProfileId ?? null,
        weight_exceeded: weightExceeded,
        country_code: countryCode ?? null,
        cost_data_available: costDataAvailable,
      }

      const { data: inserted, error: insertError } = await supabase
        .schema('batchmaker')
        .from('packaging_advice')
        .insert(adviceRow)
        .select('id, order_id, picklist_id, status, confidence, advice_boxes, shipping_units_detected, unclassified_products, tags_written, calculated_at, weight_exceeded, shipping_unit_fingerprint, cost_data_available')
        .single()

      if (insertError) {
        console.error('[packagingEngine] Error inserting single-SKU advice:', insertError)
        // Fall through to normal engine flow
      } else {
        console.log(`[packagingEngine] Single-SKU advice saved: ${inserted.id}`)
        return {
          id: inserted.id,
          order_id: inserted.order_id,
          picklist_id: inserted.picklist_id,
          status: inserted.status,
          confidence: inserted.confidence,
          advice_boxes: inserted.advice_boxes as AdviceBox[],
          shipping_units_detected: inserted.shipping_units_detected as { shipping_unit_id: string; shipping_unit_name: string; quantity: number }[],
          unclassified_products: inserted.unclassified_products as string[],
          tags_written: inserted.tags_written as string[],
          calculated_at: inserted.calculated_at,
          weight_exceeded: inserted.weight_exceeded ?? false,
          shipping_unit_fingerprint: inserted.shipping_unit_fingerprint ?? null,
          cost_data_available: inserted.cost_data_available ?? false,
        }
      }
    }
  }
}
// End of single-SKU fast path — continues to normal matchCompartments flow
```

**Key implementation notes:**
- The fast path is a SHORTCUT, not a replacement. If any condition fails (product not classified, no default packaging, packaging inactive, DB error), execution falls through to the normal engine flow seamlessly.
- `costDataAvailable` variable must be declared with `let` before this section (it currently is `let costDataAvailable = false` around line 1035). The single-SKU path may set it to true.
- Move the `let costDataAvailable = false` declaration BEFORE the single-SKU check (currently it's after matchCompartments).
- Import `selectCostForWeight` from costProvider if not already imported.
- The fast path DOES go through deduplication (fingerprint check) — same as normal flow. If fingerprint matches existing advice, the cached result is returned before the fast path even runs. Good.
- Weight validation still runs via `validateWeightsForBoxes`.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Review calculateAdvice to confirm the single-SKU fast path runs before matchCompartments and falls through gracefully on any failure condition.</manual>
  </verify>
  <done>Single-SKU fast path works: orders with 1 unique product + default_packaging_id skip compartment rules. Cost data is enriched when available. Weight validation runs. Falls through to normal engine on any failure. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Full build verification and edge case handling</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
1. Run `npm run build` to verify the full production build passes with all Phase 5 changes.

2. Verify the following edge cases are handled in the single-SKU fast path:
   - **Multiple quantity, single SKU**: Order with `[{ productcode: 'ABC', quantity: 6 }]` — should use fast path (1 unique SKU)
   - **Multiple lines, same SKU**: Order with `[{ productcode: 'ABC', qty: 3 }, { productcode: 'ABC', qty: 3 }]` — should use fast path (still 1 unique product_id)
   - **Inactive default packaging**: If the mapped packaging has `active: false`, the fast path should fall through to normal engine flow
   - **No cost data for default packaging**: If the default packaging has no cost entries for the destination country, the box should still be returned but without cost fields (same as normal flow degradation)
   - **Product with default_packaging_id = null**: Falls through to normal engine flow (no fast path)
   - **Multi-SKU order**: Order with 2+ unique product IDs — fast path does NOT fire, normal engine flow runs

3. Verify import chain:
   - `selectCostForWeight` imported from `./costProvider`
   - All CostEntry[] handling is consistent with Phase 4 types
   - No type errors in the full codebase

4. If build fails, fix the issues. Common causes:
   - Type mismatch with CostEntry[] vs CostEntry (Phase 4 change)
   - Missing import for selectCostForWeight
   - Optional chaining needed for new fields

5. Verify the costDataAvailable variable is correctly scoped — it must be accessible both in the single-SKU fast path AND the normal engine flow. Move its declaration to before the single-SKU check if needed.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npm run build 2>&1 | tail -20</automated>
    <manual>Verify the build succeeds with exit code 0. Check that no TypeScript errors exist in the engine files.</manual>
  </verify>
  <done>Full production build passes. Single-SKU fast path handles all edge cases (inactive packaging, no cost data, multi-quantity). Import chain is intact. costDataAvailable scoping is correct.</done>
</task>

</tasks>

<verification>
1. Full build succeeds: `npm run build`
2. Single-SKU fast path fires for 1-unique-product orders with default_packaging_id
3. Fast path bypasses matchCompartments/rankPackagings/solveMultiBox
4. Cost enrichment works on fast path boxes
5. Normal engine flow is unaffected for multi-SKU orders
6. Graceful fallthrough on any fast path failure
</verification>

<success_criteria>
- Orders with 1 unique SKU + default packaging use the fast path
- The single-SKU mapping has priority over compartment rules (engine is bypassed)
- Orders with multiple SKUs or no default mapping go through normal engine
- Single-SKU boxes are enriched with cost data when available
- Full production build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-engine-optimization/05-03-SUMMARY.md`
</output>
