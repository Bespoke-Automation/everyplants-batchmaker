---
phase: 05-engine-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/productAttributes.ts
  - src/types/verpakking.ts
  - src/app/api/verpakking/product-attributes/default-packaging/route.ts
  - src/components/verpakking/ProductStatus.tsx
autonomous: true
requirements:
  - SINGLE-01

must_haves:
  truths:
    - "Each product (SKU) can have a default_packaging_id stored in product_attributes"
    - "Admin can set/clear the default packaging for any classified product via the UI"
    - "The API persists default_packaging_id changes to the database"
  artifacts:
    - path: "src/lib/supabase/productAttributes.ts"
      provides: "updateDefaultPackaging function for setting product default packaging"
      contains: "default_packaging_id"
    - path: "src/app/api/verpakking/product-attributes/default-packaging/route.ts"
      provides: "PUT endpoint for setting default packaging per product"
      exports: ["PUT"]
    - path: "src/components/verpakking/ProductStatus.tsx"
      provides: "Admin UI for viewing and editing default packaging per product"
      contains: "default_packaging_id"
  key_links:
    - from: "src/components/verpakking/ProductStatus.tsx"
      to: "/api/verpakking/product-attributes/default-packaging"
      via: "fetch PUT call to update default packaging"
      pattern: "default-packaging"
    - from: "src/app/api/verpakking/product-attributes/default-packaging/route.ts"
      to: "src/lib/supabase/productAttributes.ts"
      via: "updateDefaultPackaging() function call"
      pattern: "updateDefaultPackaging"
---

<objective>
Add the ability to map a default packaging to each product (SKU) in the product_attributes table, with an admin UI for managing these mappings.

Purpose: Single-SKU orders (orders with only 1 unique product) can bypass the compartment rules engine entirely and use a pre-configured default packaging. This plan creates the data layer and admin interface; the engine integration follows in Plan 03.

Output: Database column, API endpoint, admin UI for managing product-to-packaging mappings.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/supabase/productAttributes.ts
@src/components/verpakking/ProductStatus.tsx
@src/types/verpakking.ts
@src/hooks/useLocalPackagings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add default_packaging_id column and Supabase helper</name>
  <files>src/lib/supabase/productAttributes.ts, src/types/verpakking.ts</files>
  <action>
1. Run a Supabase migration using `mcp__supabase__apply_migration` with name `add_default_packaging_to_product_attributes`. The migration should:
   - ADD COLUMN `default_packaging_id UUID REFERENCES batchmaker.packagings(id) ON DELETE SET NULL DEFAULT NULL` to `batchmaker.product_attributes`
   - ADD a COMMENT on the column: 'Default packaging for single-SKU orders. When set, bypasses compartment rules for orders with only this product.'

2. Update `src/lib/supabase/productAttributes.ts`:
   - Add a new exported function `updateDefaultPackaging(productAttributeId: string, packagingId: string | null): Promise<void>` that runs:
     ```
     await supabase
       .schema('batchmaker')
       .from('product_attributes')
       .update({ default_packaging_id: packagingId })
       .eq('id', productAttributeId)
     ```
   - Add a new exported function `getProductsWithDefaultPackaging(): Promise<Array<{ id: string; productcode: string; product_name: string; default_packaging_id: string | null }>>` that fetches all classified products with their default_packaging_id.

3. No changes needed to `src/types/verpakking.ts` for this task — the ProductStatus component uses its own inline types from the API response. The engine types (PackagingMatch, AdviceBox) don't need updating for the data layer.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify migration was applied by checking: SELECT column_name FROM information_schema.columns WHERE table_schema='batchmaker' AND table_name='product_attributes' AND column_name='default_packaging_id'</manual>
  </verify>
  <done>The product_attributes table has a default_packaging_id column with FK to packagings. Helper functions exist for reading and writing the mapping.</done>
</task>

<task type="auto">
  <name>Task 2: Add API endpoint and admin UI for default packaging management</name>
  <files>src/app/api/verpakking/product-attributes/default-packaging/route.ts, src/components/verpakking/ProductStatus.tsx</files>
  <action>
1. Create `src/app/api/verpakking/product-attributes/default-packaging/route.ts`:
   ```typescript
   export const dynamic = 'force-dynamic'
   ```
   - **PUT handler**: Accepts JSON body `{ productAttributeId: string, packagingId: string | null }`. Calls `updateDefaultPackaging()`. Returns `{ success: true }` on success, `{ error: string }` with 400/500 on failure. Validate that productAttributeId is provided.

2. Update `src/components/verpakking/ProductStatus.tsx` to show and manage default packaging:
   - The ProductStatus component already shows a table of products with their classification status. Read the existing component first to understand the current structure.
   - Add a "Standaard verpakking" column to the product table. For each product row, show a dropdown/select with all active packagings (fetch from `/api/verpakking/packagings` or use the existing data if already fetched). The dropdown should:
     - Show "Geen standaard" as the default/empty option
     - List all active packagings by name
     - On change, call PUT `/api/verpakking/product-attributes/default-packaging` with the product's ID and selected packaging ID (or null for "Geen standaard")
     - Show a brief loading state during save (spinner icon)
     - After save, update the local state to reflect the change
   - For the packaging list data, fetch packagings once on mount via `/api/verpakking/packagings` (GET) and store in state. Map `id -> name` for the dropdown options.
   - Only show the default packaging column for products with `classification_status = 'classified'` — unclassified products don't need a default packaging.
   - Use the same Tailwind styling patterns as the rest of the table (text-sm, consistent padding, emerald for success states).
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Visit /verpakkingsmodule/instellingen, go to the product status tab, verify the "Standaard verpakking" dropdown appears for classified products. Select a packaging for a product and verify it persists after page refresh.</manual>
  </verify>
  <done>Admin can set/clear the default packaging for any classified product. The dropdown shows all active packagings. Changes persist via the API endpoint. The column only shows for classified products.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Database column exists on product_attributes
3. API endpoint responds to PUT with valid payload
4. Admin UI shows dropdown for classified products
5. Changes persist across page refresh
</verification>

<success_criteria>
- product_attributes has default_packaging_id column with FK to packagings
- Admin can set any active packaging as default for a product
- Admin can clear the default packaging (set to null)
- API validates input and returns proper error responses
</success_criteria>

<output>
After completion, create `.planning/phases/05-engine-optimization/05-01-SUMMARY.md`
</output>
