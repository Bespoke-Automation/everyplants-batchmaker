---
phase: 05-engine-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/packagingEngine.ts
autonomous: true
requirements:
  - RANK-01
  - RANK-02
  - RANK-03
  - RANK-04
  - MULTI-01
  - MULTI-02

must_haves:
  truths:
    - "rankPackagings sorts by total_cost ASC where total_cost = box_material + pick + pack + transport"
    - "Boxes without preferred route for destination country are excluded by enrichWithCosts"
    - "Equal-cost boxes fall back to specificity DESC then volume ASC tiebreakers"
    - "Multi-box solver evaluates multiple packaging combinations to find lowest total cost"
    - "Multi-box solver has 200ms timeout with fallback to existing greedy algorithm"
  artifacts:
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "Updated ranking with full cost formula and non-greedy multi-box solver"
      contains: "solveMultiBoxOptimal"
  key_links:
    - from: "src/lib/engine/packagingEngine.ts enrichWithCosts"
      to: "src/lib/engine/costProvider.ts"
      via: "CostEntry.totalCost includes pick+pack from published_box_costs"
      pattern: "totalCost"
    - from: "src/lib/engine/packagingEngine.ts solveMultiBox"
      to: "solveMultiBoxOptimal"
      via: "New solver called from existing solveMultiBox with timeout wrapper"
      pattern: "solveMultiBoxOptimal"
---

<objective>
Update the ranking to use the full cost formula from Phase 4 (total_cost includes pick/pack from published_box_costs) and replace the greedy multi-box solver with a cost-optimal solver that evaluates multiple combinations.

Purpose: The greedy solver picks the box with best coverage first, which may not produce the cheapest combination. For orders requiring 2-4 boxes, evaluating combinations can find significantly cheaper solutions. The 200ms timeout ensures no performance regression.

Output: Updated ranking logic and non-greedy multi-box solver in packagingEngine.ts.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/engine/packagingEngine.ts
@src/lib/engine/costProvider.ts
@src/types/verpakking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and update ranking for full cost formula</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
Read the current packagingEngine.ts and costProvider.ts carefully. After Phase 4:
- costProvider returns `CostEntry[]` per SKU (multiple weight brackets)
- `CostEntry.totalCost` from `published_box_costs.total_cost` already = box_material + pick + pack + transport
- `enrichWithCosts` uses `facturatie_box_sku` for lookup and sets `total_cost = entry.totalCost`
- `rankPackagings` sorts by `total_cost ASC` when `costDataAvailable = true`

**Verify RANK-01/RANK-02**: The existing `enrichWithCosts` sets `total_cost` from `CostEntry.totalCost` which Phase 4 makes equal to box_material + pick + pack + transport. Confirm this chain is intact. If `enrichWithCosts` still computes `box_cost + transport_cost` manually, update it to use `entry.totalCost` directly (which already includes all components).

**Verify RANK-03**: `enrichWithCosts` already returns `null` (excluded) when a packaging has `facturatie_box_sku` but no cost entries for the country. Confirm this path handles the new `CostEntry[]` array type correctly. A packaging should be excluded if:
- It has a `facturatie_box_sku` but the SKU has NO entries in the cost map for this country
- This means no preferred route exists for this destination

**Verify RANK-04**: `rankPackagings` already has specificity DESC and volume ASC as tiebreakers. Confirm these still work correctly.

**If any of the above are broken or need updating:**
- Fix `enrichWithCosts` to handle `CostEntry[]` array (pick the appropriate entry — for initial ranking before weight is known, use the NULL weight_bracket entry or lightest bracket as estimate)
- Fix `rankPackagings` if cost comparison logic needs adjustment
- Ensure `box_cost`, `transport_cost` on PackagingMatch are set correctly for downstream UI consumption (box_cost = boxMaterialCost, transport_cost = transportCost from CostEntry)

**Important**: The `total_cost` on PackagingMatch MUST be set from `entry.totalCost` (which is the pre-calculated sum from published_box_costs), NOT from `box_cost + transport_cost` (which would miss pick/pack). Add a comment documenting this: `// total_cost from published_box_costs includes: box_material + pick + pack + transport`.

After making changes, ensure TypeScript compiles.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Grep for "entry.totalCost" or "total_cost" in enrichWithCosts to confirm the full formula is used, not a partial sum.</manual>
  </verify>
  <done>enrichWithCosts sets total_cost from CostEntry.totalCost (full formula). rankPackagings sorts by total_cost ASC with specificity/volume tiebreakers. Boxes without preferred routes are excluded. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Implement non-greedy cost-optimal multi-box solver</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
Replace the greedy multi-box section inside `solveMultiBox` (the `while (pool.size > 0)` loop at ~line 732) with a cost-optimal solver that has a 200ms timeout and falls back to the existing greedy algorithm.

**Algorithm: Bounded Branch-and-Bound**

Create a new function `solveMultiBoxOptimal` that:

1. **Input**: The mixable remaining pool (`Map<string, ShippingUnitEntry>`), list of candidate `PackagingMatch[]` from `matchCompartments`, `costMap`, `costDataAvailable`, `products`, `mixableMap`.

2. **Candidate generation**: For each distinct packaging in the matches list, evaluate it against the current remaining pool. A candidate is valid if it covers at least 1 shipping unit. Store: which units it covers, its cost (total_cost from the match).

3. **Search**: Use iterative deepening / branch-and-bound:
   - Start with the cheapest single-box candidate. If it covers everything, that's the optimal 1-box solution.
   - For each candidate, remove covered units from pool, recurse with remaining pool.
   - Track best-so-far (lowest total cost across all boxes).
   - **Pruning**: If current path cost already exceeds best-so-far, skip (branch-and-bound).
   - **Depth limit**: Max 5 boxes (typical orders need 2-4). If depth > 5, abandon this branch.
   - **Timeout**: Check `performance.now()` (or `Date.now()`) at each recursion. If > 200ms elapsed from start, stop and return best-so-far (or null if none found yet).

4. **Timeout fallback**: If `solveMultiBoxOptimal` returns null (timeout with no solution) OR was interrupted before finding any valid solution, fall back to the existing greedy algorithm. Keep the greedy code as a separate function `solveMultiBoxGreedy` extracted from the current while-loop.

5. **Result format**: Return `AdviceBox[]` — same as current greedy produces.

**Implementation structure**:

```typescript
interface MultiBoxCandidate {
  match: PackagingMatch
  coveredUnits: Map<string, number>  // what this box covers
  cost: number                        // total_cost of this box
}

interface MultiBoxSolution {
  boxes: MultiBoxCandidate[]
  totalCost: number
}

function solveMultiBoxOptimal(
  pool: Map<string, ShippingUnitEntry>,
  candidates: PackagingMatch[],
  costDataAvailable: boolean,
  timeoutMs: number = 200
): MultiBoxSolution | null {
  const startTime = Date.now()
  let bestSolution: MultiBoxSolution | null = null

  function search(
    remaining: Map<string, ShippingUnitEntry>,
    currentBoxes: MultiBoxCandidate[],
    currentCost: number,
    depth: number
  ): void {
    // Timeout check
    if (Date.now() - startTime > timeoutMs) return

    // All units placed?
    if (remaining.size === 0) {
      if (!bestSolution || currentCost < bestSolution.totalCost) {
        bestSolution = { boxes: [...currentBoxes], totalCost: currentCost }
      }
      return
    }

    // Depth limit
    if (depth >= 5) return

    // Pruning: if current cost already >= best, skip
    if (bestSolution && currentCost >= bestSolution.totalCost) return

    // Try each candidate against remaining pool
    for (const candidate of candidates) {
      // Check if candidate covers any remaining units
      const covered = new Map<string, number>()
      let coversAnything = false
      for (const [unitId, qty] of candidate.covered_units) {
        const available = remaining.get(unitId)
        if (available && available.quantity > 0) {
          const consume = Math.min(qty, available.quantity)
          covered.set(unitId, consume)
          coversAnything = true
        }
      }
      if (!coversAnything) continue

      // Build reduced pool
      const newRemaining = new Map<string, ShippingUnitEntry>()
      for (const [id, entry] of remaining) {
        const consumed = covered.get(id) ?? 0
        const left = entry.quantity - consumed
        if (left > 0) {
          newRemaining.set(id, { ...entry, quantity: left })
        }
      }

      const boxCandidate: MultiBoxCandidate = {
        match: candidate,
        coveredUnits: covered,
        cost: candidate.total_cost
      }

      search(
        newRemaining,
        [...currentBoxes, boxCandidate],
        currentCost + candidate.total_cost,
        depth + 1
      )

      // Early exit on timeout
      if (Date.now() - startTime > timeoutMs) return
    }
  }

  // Sort candidates by total_cost ASC for better pruning
  const sortedCandidates = [...candidates].sort((a, b) => a.total_cost - b.total_cost)
  search(pool, [], 0, 0)
  return bestSolution
}
```

**Integration into solveMultiBox**:

In the `else` branch of `if (singleBoxMatch)` (around line 722), replace the greedy while-loop:

```typescript
// 1. Try cost-optimal solver (with 200ms timeout)
if (costDataAvailable) {
  // Generate fresh candidates for the remaining pool
  const poolMatches = await matchCompartments(pool)
  const enrichedPool = enrichWithCosts(poolMatches, costMap)

  const optimalSolution = solveMultiBoxOptimal(
    pool,
    enrichedPool,
    costDataAvailable,
    200  // 200ms timeout
  )

  if (optimalSolution && optimalSolution.boxes.length > 0) {
    console.log(`[packagingEngine] Optimal multi-box: ${optimalSolution.boxes.length} boxes, total EUR ${(optimalSolution.totalCost / 100).toFixed(2)} (found in ${Date.now() - searchStart}ms)`)

    // Convert MultiBoxCandidate[] to AdviceBox[]
    for (const candidate of optimalSolution.boxes) {
      const boxProducts = buildProductList(candidate.coveredUnits, pool, products, mixableMap)
      boxes.push({
        packaging_id: candidate.match.packaging_id,
        packaging_name: candidate.match.packaging_name,
        idpackaging: candidate.match.idpackaging,
        products: boxProducts,
        box_cost: candidate.match.box_cost || undefined,
        transport_cost: candidate.match.transport_cost || undefined,
        total_cost: candidate.cost || undefined,
      })
    }
    // Clear pool (all placed)
    pool.clear()
  }
}

// 2. Fallback: greedy solver (when optimal didn't find solution or no cost data)
if (pool.size > 0) {
  // ... existing greedy while-loop code, extracted into solveMultiBoxGreedy()
}
```

**Extract greedy solver**: Move the existing while-loop into a separate function `solveMultiBoxGreedy(pool, products, mixableMap, costMap, costDataAvailable)` that returns `AdviceBox[]`. This keeps the code clean and makes the fallback explicit.

**Important edge cases**:
- If costDataAvailable is false, skip optimal solver entirely and use greedy (no point optimizing on cost if we don't have cost data)
- If the optimal solver returns a solution that uses more boxes than greedy would, still prefer optimal if total cost is lower
- Log when falling back to greedy: `[packagingEngine] Multi-box: falling back to greedy solver (timeout/no optimal solution)`
- The `buildProductList` call uses the original `pool` Map (before clearing). Make sure to call buildProductList BEFORE clearing pool for each box. Actually, create a snapshot of pool before the optimal solver runs.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Review the solveMultiBoxOptimal function for correctness: verify branch-and-bound pruning, timeout check, depth limit, and candidate evaluation.</manual>
  </verify>
  <done>Non-greedy cost-optimal solver evaluates combinations with branch-and-bound. 200ms timeout with greedy fallback. Greedy code extracted to solveMultiBoxGreedy. Optimal solver only runs when costDataAvailable is true. TypeScript compiles.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. rankPackagings uses total_cost from CostEntry (includes pick+pack)
3. enrichWithCosts excludes boxes without preferred route
4. solveMultiBoxOptimal exists with branch-and-bound search
5. 200ms timeout + greedy fallback is implemented
6. Greedy solver preserved as solveMultiBoxGreedy
</verification>

<success_criteria>
- Ranking sorts by full total_cost (box_material + pick + pack + transport) ASC
- Boxes without preferred route for country are excluded from candidates
- Equal-cost boxes use specificity then volume as tiebreakers
- Multi-box solver finds cost-optimal combination within 200ms
- Greedy fallback activates on timeout or when cost data unavailable
- Full production build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-engine-optimization/05-02-SUMMARY.md`
</output>
