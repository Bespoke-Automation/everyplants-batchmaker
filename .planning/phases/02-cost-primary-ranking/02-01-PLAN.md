---
phase: 02-cost-primary-ranking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/engine/packagingEngine.ts
autonomous: true
requirements: [ENG-01]

must_haves:
  truths:
    - "rankPackagings() sorts primarily on total_cost ASC when cost data is available"
    - "When cost data is NOT available, rankPackagings() preserves original specificity-based sort"
    - "enrichWithCosts() maps cost provider data onto PackagingMatch entries and filters out matches with no preferred route"
    - "Packagings without barcode are kept with their original total_cost (not excluded, not zero-cost)"
    - "solveMultiBox inner matchCompartments calls produce enriched matches before ranking"
    - "AdviceBox records carry box_cost, transport_cost, total_cost from their selected PackagingMatch"
    - "Multi-box advice uses the same country-specific cost data as single-box advice"
  artifacts:
    - path: "src/lib/engine/packagingEngine.ts"
      provides: "enrichWithCosts function, cost-primary rankPackagings, cost threading through solveMultiBox, cost fields on AdviceBox"
      contains: "enrichWithCosts"
  key_links:
    - from: "enrichWithCosts()"
      to: "costProvider.getAllCostsForCountry()"
      via: "Map<string, CostEntry> costMap parameter"
      pattern: "enrichWithCosts.*costMap"
    - from: "calculateAdvice()"
      to: "enrichWithCosts()"
      via: "called after matchCompartments and before rankPackagings"
      pattern: "enrichWithCosts\\(matches"
    - from: "solveMultiBox()"
      to: "enrichWithCosts()"
      via: "costMap param threaded through, called after each inner matchCompartments"
      pattern: "enrichWithCosts\\(.*Matches.*costMap"
    - from: "rankPackagings()"
      to: "costDataAvailable param"
      via: "boolean flag switching sort order"
      pattern: "rankPackagings\\(.*costDataAvailable"
    - from: "AdviceBox"
      to: "PackagingMatch cost fields"
      via: "box_cost, transport_cost, total_cost copied from selected match"
      pattern: "box_cost.*transport_cost.*total_cost"
---

<objective>
Implement cost-primary ranking in the packaging engine: enrich matches with cost provider data, sort by total cost ASC as primary criterion, thread cost context through multi-box solver, and carry cost fields on AdviceBox for downstream use.

Purpose: This is the core algorithmic change that delivers the project's central value -- always recommend the cheapest packaging option per destination country.
Output: Modified `packagingEngine.ts` with `enrichWithCosts()`, cost-primary `rankPackagings()`, cost-threaded `solveMultiBox()`, and cost-enriched `AdviceBox`.
</objective>

<execution_context>
@/Users/kennylipman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kennylipman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cost-primary-ranking/02-RESEARCH.md
@.planning/phases/01-cost-data-layer/01-01-SUMMARY.md
@.planning/phases/01-cost-data-layer/01-02-SUMMARY.md
@src/lib/engine/packagingEngine.ts
@src/lib/engine/costProvider.ts
@src/types/verpakking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add barcode to interfaces/query, create enrichWithCosts(), modify rankPackagings() sort, add cost fields to AdviceBox</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
This task adds the data plumbing and the two core pure functions. All changes are in `packagingEngine.ts`.

**1a. Add `barcode` to `PackagingRow` interface (line ~110-120):**
```typescript
interface PackagingRow {
  id: string
  idpackaging: number
  name: string
  barcode: string | null  // NEW — join key for cost provider lookup
  picqer_tag_name: string | null
  specificity_score: number
  volume: number | null
  handling_cost: number | null
  material_cost: number | null
  max_weight: number | null
}
```

**1b. Add `barcode`, `box_cost`, `transport_cost` to `PackagingMatch` interface (line ~36-47):**
```typescript
export interface PackagingMatch {
  packaging_id: string
  packaging_name: string
  idpackaging: number
  barcode: string | null      // NEW — from packagings.barcode, used as cost lookup key
  rule_group: number
  covered_units: Map<string, number>
  leftover_units: Map<string, number>
  specificity_score: number
  volume: number
  box_cost: number            // NEW — from CostEntry.boxCost (0 if not enriched)
  transport_cost: number      // NEW — from CostEntry.transportCost (0 if not enriched)
  total_cost: number
  max_weight: number
}
```

**1c. Add cost fields to `AdviceBox` interface (line ~49-54):**
```typescript
export interface AdviceBox {
  packaging_id: string
  packaging_name: string
  idpackaging: number
  products: { productcode: string; shipping_unit_name: string; quantity: number }[]
  box_cost?: number        // NEW — from selected PackagingMatch
  transport_cost?: number  // NEW — from selected PackagingMatch
  total_cost?: number      // NEW — from selected PackagingMatch
}
```

**1d. Add `barcode` to the SELECT query in `matchCompartments()` (line ~356):**
Change the `.select()` call to include `barcode`:
```typescript
.select('id, idpackaging, name, barcode, picqer_tag_name, specificity_score, volume, handling_cost, material_cost, max_weight')
```

**1e. Add `barcode` and `box_cost`/`transport_cost` to the match construction in `matchCompartments()` (line ~409-420):**
```typescript
matches.push({
  packaging_id: pkg.id,
  packaging_name: pkg.picqer_tag_name || pkg.name,
  idpackaging: pkg.idpackaging,
  barcode: pkg.barcode ?? null,  // NEW
  rule_group: groupNum,
  covered_units: matchResult.covered,
  leftover_units: matchResult.leftover,
  specificity_score: pkg.specificity_score ?? 50,
  volume: pkg.volume ?? Infinity,
  box_cost: 0,            // NEW — will be enriched by enrichWithCosts()
  transport_cost: 0,      // NEW — will be enriched by enrichWithCosts()
  total_cost: (pkg.handling_cost ?? 0) + (pkg.material_cost ?? 0),
  max_weight: pkg.max_weight ?? Infinity,
})
```

**1f. Add import of `CostEntry` type at top of file (after existing imports, line ~15):**
```typescript
import type { CostEntry } from './costProvider'
```

**1g. Create `enrichWithCosts()` function — place it between `matchCompartments` and `rankPackagings` sections (between line ~427 and line ~518):**

```typescript
// ── 2b. enrichWithCosts ─────────────────────────────────────────────────

/**
 * Enrich packaging matches with cost data from the cost provider.
 * - Matches whose barcode has a cost entry: overwrite box_cost, transport_cost, total_cost
 * - Matches whose barcode has NO cost entry: EXCLUDED (no preferred route for this country)
 * - Matches without barcode: kept with original total_cost (can't look up, but not excluded)
 * - If costMap is null (no cost data): return matches unchanged (graceful degradation)
 */
function enrichWithCosts(
  matches: PackagingMatch[],
  costMap: Map<string, CostEntry> | null
): PackagingMatch[] {
  if (!costMap) return matches  // No cost data → keep original costs

  return matches
    .map(match => {
      if (!match.barcode) return match  // No barcode → can't look up, keep as-is

      const cost = costMap.get(match.barcode)
      if (!cost) return null  // No preferred route for this country → EXCLUDE

      return {
        ...match,
        box_cost: cost.boxCost,
        transport_cost: cost.transportCost,
        total_cost: cost.boxCost + cost.transportCost,
      }
    })
    .filter((m): m is PackagingMatch => m !== null)
}
```

**1h. Modify `rankPackagings()` to accept `costDataAvailable` parameter and change sort order (line ~520):**

```typescript
export function rankPackagings(
  matches: PackagingMatch[],
  costDataAvailable: boolean = false
): PackagingMatch[] {
  return [...matches].sort((a, b) => {
    if (costDataAvailable) {
      // PRIMARY: total_cost ASC (cheapest first)
      if (a.total_cost !== b.total_cost) {
        return a.total_cost - b.total_cost
      }
      // TIEBREAKER 1: specificity_score DESC (most specific first)
      if (b.specificity_score !== a.specificity_score) {
        return b.specificity_score - a.specificity_score
      }
      // TIEBREAKER 2: volume ASC (smallest box first)
      return a.volume - b.volume
    }
    // Fallback: original ranking (no cost data)
    if (b.specificity_score !== a.specificity_score) {
      return b.specificity_score - a.specificity_score
    }
    if (a.volume !== b.volume) {
      return a.volume - b.volume
    }
    return a.total_cost - b.total_cost
  })
}
```

**Important: Do NOT introduce `import { CostEntry } from ...` — use `import type { CostEntry }` since it's only used as a type.**
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify enrichWithCosts function exists and rankPackagings accepts costDataAvailable parameter</manual>
  </verify>
  <done>
    - PackagingRow has barcode field
    - PackagingMatch has barcode, box_cost, transport_cost fields
    - AdviceBox has optional box_cost, transport_cost, total_cost fields
    - matchCompartments SELECT includes barcode, match construction includes barcode and zero-initialized cost fields
    - enrichWithCosts() exists as a pure function that enriches from costMap and filters no-route matches
    - rankPackagings() accepts costDataAvailable boolean and sorts cost-primary when true
    - TypeScript compiles without errors in packagingEngine.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread cost map through solveMultiBox and connect enrichment in calculateAdvice</name>
  <files>src/lib/engine/packagingEngine.ts</files>
  <action>
This task wires everything together: passes costMap through the call chain so all 4 rankPackagings call sites use enriched data with the correct flag.

**2a. Modify `solveMultiBox()` signature to accept cost context (line ~537-542):**

```typescript
export async function solveMultiBox(
  shippingUnits: Map<string, ShippingUnitEntry>,
  unclassified: string[],
  allMatches: PackagingMatch[],
  products: OrderProduct[],
  costMap: Map<string, CostEntry> | null = null,       // NEW
  costDataAvailable: boolean = false                     // NEW
): Promise<{ boxes: AdviceBox[]; confidence: 'full_match' | 'partial_match' | 'no_match' }>
```

**2b. In `solveMultiBox()` — non-mixable product handling (around line ~609-610):**
After `matchCompartments(singleUnit)`, enrich before ranking:
```typescript
const singleMatches = await matchCompartments(singleUnit)
const enrichedSingle = enrichWithCosts(singleMatches, costMap)  // NEW
const ranked = rankPackagings(enrichedSingle, costDataAvailable)  // CHANGED: pass flag
```

**2c. In `solveMultiBox()` — non-mixable box construction (around line ~616-625):**
Add cost fields to the AdviceBox:
```typescript
if (perfectMatch) {
  boxes.push({
    packaging_id: perfectMatch.packaging_id,
    packaging_name: perfectMatch.packaging_name,
    idpackaging: perfectMatch.idpackaging,
    products: [{
      productcode: nm.product.productcode,
      shipping_unit_name: nm.shipping_unit_name,
      quantity: 1,
    }],
    box_cost: perfectMatch.box_cost || undefined,          // NEW
    transport_cost: perfectMatch.transport_cost || undefined, // NEW
    total_cost: perfectMatch.total_cost || undefined,        // NEW
  })
}
```

**2d. In `solveMultiBox()` — mixable products ranking (around line ~643):**
Pass costDataAvailable to rankPackagings:
```typescript
const ranked = rankPackagings(mixableMatches, costDataAvailable)  // CHANGED: pass flag
```

**2e. In `solveMultiBox()` — single-box match construction (around line ~648-656):**
Add cost fields to the AdviceBox:
```typescript
if (singleBoxMatch) {
  const boxProducts = buildProductList(singleBoxMatch.covered_units, shippingUnits, products, mixableMap)
  boxes.push({
    packaging_id: singleBoxMatch.packaging_id,
    packaging_name: singleBoxMatch.packaging_name,
    idpackaging: singleBoxMatch.idpackaging,
    products: boxProducts,
    box_cost: singleBoxMatch.box_cost || undefined,          // NEW
    transport_cost: singleBoxMatch.transport_cost || undefined, // NEW
    total_cost: singleBoxMatch.total_cost || undefined,        // NEW
  })
}
```

**2f. In `solveMultiBox()` — greedy multi-box loop (around line ~671-672):**
After `matchCompartments(pool)`, enrich before ranking:
```typescript
const poolMatches = await matchCompartments(pool)
const enrichedPool = enrichWithCosts(poolMatches, costMap)  // NEW
const poolRanked = rankPackagings(enrichedPool, costDataAvailable)  // CHANGED: pass flag
```

**2g. In `solveMultiBox()` — greedy loop box construction (around line ~683-689):**
Add cost fields to the AdviceBox:
```typescript
boxes.push({
  packaging_id: bestMatch.packaging_id,
  packaging_name: bestMatch.packaging_name,
  idpackaging: bestMatch.idpackaging,
  products: boxProducts,
  box_cost: bestMatch.box_cost || undefined,          // NEW
  transport_cost: bestMatch.transport_cost || undefined, // NEW
  total_cost: bestMatch.total_cost || undefined,        // NEW
})
```

**2h. In `calculateAdvice()` — connect the enrichment pipeline (around lines ~962-981):**
Replace the current Step 2b cost check (which fetches costs but doesn't use them) and Step 3 ranking with the enrichment pipeline. The flow becomes:

```typescript
// Step 2: Match compartments
const matches = await matchCompartments(shippingUnits)

// Step 2b: Cost data enrichment
let costDataAvailable = false
let costMap: Map<string, CostEntry> | null = null

if (countryCode) {
  costMap = await getAllCostsForCountry(countryCode)
  costDataAvailable = costMap !== null
  if (!costDataAvailable) {
    console.warn(`[packagingEngine] Cost data unavailable for ${countryCode}, using specificity ranking`)
  }
} else {
  console.warn(`[packagingEngine] No countryCode provided, cost data not available`)
}

// Step 2c: Enrich matches with cost data + filter unavailable routes
const enrichedMatches = enrichWithCosts(matches, costMap)

// Step 3: Rank (with cost-primary if available)
const ranked = rankPackagings(enrichedMatches, costDataAvailable)

// Step 4: Solve multi-box (pass cost context through)
let { boxes, confidence } = await solveMultiBox(
  shippingUnits, unclassified, ranked, products,
  costMap, costDataAvailable  // NEW params
)
```

**Important notes:**
- The `costMap` variable now needs to be declared with `let` and its type explicitly as `Map<string, CostEntry> | null` in the calculateAdvice scope. Import `CostEntry` type is already handled in Task 1.
- The existing `costDataAvailable` variable is already declared at the right scope — just ensure the enrichment and solveMultiBox calls use it.
- Do NOT change the fallback logic (Step 4b default packaging fallback) — it already handles no_match cases and should remain unchanged.
- Use `|| undefined` (not `?? undefined`) for the optional cost fields on AdviceBox to convert `0` values from non-enriched matches to `undefined`, so only genuinely enriched cost data appears on AdviceBox.

**IMPORTANT: solveMultiBox `costMap` type annotation.** Since `CostEntry` is imported as a type, and the function uses `costMap: Map<string, CostEntry> | null`, TypeScript needs the type available. The `import type` from Task 1 is sufficient for this.
  </action>
  <verify>
    <automated>cd /Users/kennylipman/everyplants-batchmaker && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify that all 4 rankPackagings call sites pass costDataAvailable, and all inner matchCompartments results are enriched before ranking</manual>
  </verify>
  <done>
    - solveMultiBox() accepts costMap and costDataAvailable params (with defaults for backward compat)
    - All 4 rankPackagings() call sites pass costDataAvailable flag
    - All 3 inner matchCompartments() call sites in solveMultiBox are followed by enrichWithCosts()
    - All AdviceBox constructions include optional cost fields from selected match
    - calculateAdvice() enriches matches after matchCompartments and before rankPackagings
    - calculateAdvice() passes costMap and costDataAvailable to solveMultiBox
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes — TypeScript compiles cleanly
2. Grep confirms enrichWithCosts exists: `grep -n 'enrichWithCosts' src/lib/engine/packagingEngine.ts`
3. Grep confirms all 4 rankPackagings calls pass costDataAvailable: `grep -n 'rankPackagings(' src/lib/engine/packagingEngine.ts` — each should have a second argument
4. Grep confirms barcode in SELECT: `grep -n 'barcode' src/lib/engine/packagingEngine.ts` — should appear in PackagingRow, PackagingMatch, SELECT query, match construction, and enrichWithCosts
5. Grep confirms cost fields on AdviceBox construction: `grep -n 'box_cost\|transport_cost' src/lib/engine/packagingEngine.ts` — should appear in interface and all box push sites
</verification>

<success_criteria>
- rankPackagings() sorts primarily on total_cost ASC when costDataAvailable is true
- rankPackagings() preserves original specificity-based sort when costDataAvailable is false (no behavioral change)
- enrichWithCosts() excludes matches with barcode but no costMap entry (no preferred route)
- enrichWithCosts() keeps matches without barcode unchanged (with original total_cost)
- All inner matchCompartments calls in solveMultiBox are enriched before ranking
- AdviceBox records carry per-box cost data from the selected PackagingMatch
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-cost-primary-ranking/02-01-SUMMARY.md`
</output>
